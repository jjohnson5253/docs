---
id: create-permission-model
title: Create a permission model with Ory Permission Language
sidebar_label: Create permission model
---

```mdx-code-block
import Mermaid from "@site/src/theme/Mermaid"
```

This section guides you through creating your first permission model using the Ory Permission Language (OPL).

## What is a permission model

A permission model is a set of rules that define which relations are looked up in the database during a permission check.

Permission checks are answered based on data in the database, for example `keto-relation-tuples User:Bob is owner of Document:X`,
as well as permission rules like "all owners of a document can view it".

When you ask Ory Permissions `keto-relationships is User:Bob allowed to view on Document:X`, it will look up how Bob could have
the `view` permission, and then check if Bob is owner of the document X. The permission model tells Ory Permissions what to check
in the database.

## Define a permission model

Designing a permission model is a complex task. Ory Permissions and the Ory Permission Language, as a subset of TypeScript,
provide a streamlined approach to permissions with the benefit of being processed by a fast, global permission engine.

Just as there is no single approach for programming, there is no universally applicable guide for constructing a permission model.
Nevertheless, the following iterative process can be a good starting point:

1. Create a list of objects. Objects are the entities that you want to manage access for.
1. Make a list of relationships each object has to other objects. In a database, those would be associatons expressed with foreign
   keys.
1. Define each relation in the OPL
1. Make a list of permissions that you want to check.
1. Define each permission in the OPL
1. Test your permission model

## Example: document store

To guide you through the process of defining a permission model, this example will be used:

- A user can be the owner, editor, or viewer of a document.
- The owner of a document is also an editor of that document.
- An editor of a document is also a viewer of that document.
- Documents can be arranged into a hierarchy of folders.
- Users that can view the parent folder in the hierarchy can also view all folders and documents the parent folder contains.

### Create a list of objects and subjects

We start with the description and highlight all `objects` and `subjects` that we find:

- A `user` can be the owner, editor, or viewer of a `document`.
- The owner of a `document` is also an editor of that `document`.
- An editor of a `document` is also a viewer of that `document`.
- `Documents` can be arranged into a hierarchy of `folders`.
- `Users` that can view the parent `folder` in the hierarchy can also view all `folders` and `documents` the parent `folder`
  contains.

Therefore, we have the `User` subject and `Document` and `Folder` objects.

This list translates into our first version of the permission model.

```ts title="permissions-v1.ts"
import { Namespace, Context } from "@ory/keto-namespace-types"

// highlight-start
class User implements Namespace {}
class Document implements Namespace {}
class Folder implements Namespace {}
// highlight-end
```

:::tip

The objects and subjects from your description are [namespaces](../concepts/namespaces.mdx) in Ory Permissions, and are declared
as classes in the Ory Permission Language. The convention is to spell these class names as TypeScript classes, capitalized and in
singular form, for example `Document` instead of `documents`.

:::

### Determine relationships between objects

Read through the description sentence by sentence to find the list of relationships:

We want to model `user` access to `documents` such that `users` can be an `owner`, `editor`, or `viewer` of a `document`.

```mdx-code-block
<Mermaid
  chart={`
graph LR
    Document -->|owner| User
    Document -->|editor| User
    Document -->|viewer| User
`}
/>
```

An owner is also an editor of a `document`, and an editor is also a viewer of a `document`. Furthermore, `documents` can put into
a hierarchy of `folders`, such that being able to view the parent `folder` implies being able to view the enclosed `folders` and
`documents`.

```mdx-code-block
<Mermaid
  chart={`
graph LR
    Document -->|parent| Folder
    Folder -->|parent| Folder
    Folder -->|owner| User
    Folder -->|editor| User
    Folder -->|viewer| User
`}
/>
```

Putting this all together in one graph:

```mdx-code-block
<Mermaid
  chart={`
graph LR
    Document -->|owner| User
    Document -->|editor| User
    Document -->|viewer| User
    Document -->|parent| Folder
    Folder -->|parent| Folder
    Folder -->|owner| User
    Folder -->|editor| User
    Folder -->|viewer| User
`}
/>
```

### Define relations in the OPL

Next, add each relation to the permission config.

:::tip

The relations from the description translate to relationships in Ory Permissions, which are declared inside the corresponding
class in the Ory Permission Language. Since you store arbitrary tuples in Ory Permissions, you always have many-to-many relations
between these objects. To reflect this in our language, the convention is to pluralize the relation name, for example, `viewers`
instead of `viewer`.

:::

```ts title="permissions-v2.ts"
import { Namespace, Context } from "@ory/keto-namespace-types"

class User implements Namespace {}

class Document implements Namespace {
  // highlight-start
  related: {
    owners: User[]
    editors: User[]
    viewers: User[]
    parents: Folder[]
  }
  // highlight-end
}

class Folder implements Namespace {
  // highlight-start
  related: {
    owners: User[]
    editors: User[]
    viewers: User[]
    parents: Folder[]
  }
  // highlight-end
}
```

### List permissions to check for each object

When you perform an action on behalf of a user, you should check a specific permission, such as `view` or `edit`, instead of a
relationship, such as `owner`. Therefore, each permission is derived from relationships and other permissions.

Add these permissions to the model to express what the application needs. For our document storage, you have these permissions:

- `view` a document if the user is a `viewer`, `editor`, or `owner` of the document; or if the user can `view` the parent folder
- `edit` a document if the user is a `editor`, or `owner` of the document; or if the user can `edit` the parent folder
- `delete` a document if the user is an `owner` of the document; or if the user can `delete` the parent folder
- `share` a document if the user is an `owner` of the document; or if the user can `share` the parent folder
- `delete` a folder if the user is an `owner` of the folder; or if the user can `delete` the parent folder
- `share` a folder if the user is an `owner` of the folder; or if the user can `share` the parent folder

### Define permissions in the OPL

The permissions are expressed in the OPL as TypeScript functions that take a context containing the subject, for example the
current user, and that answer the permission check based on the relationships this object has, in this case the current document.

:::tip

The permissions from the description are declared as functions inside the `permits` property of the corresponding class in the
OPL.

:::

Let's see this in action for the first permission:

- `view` a document if the user is a `viewer`, `editor`, or `owner` of the document; or if the user can `view` the parent folder

```ts title="permissions-v3.ts"
import { Namespace, Context } from "@ory/keto-namespace-types"

class User implements Namespace {}

class Document implements Namespace {
  related: {
    owners: User[]
    editors: User[]
    viewers: User[]
    parents: Folder[]
  }

  permits = {
    //highlight-start
    view: (ctx: Context): boolean =>
      this.related.viewers.includes(ctx.subject) ||
      this.related.editors.includes(ctx.subject) ||
      this.related.owners.includes(ctx.subject) ||
      this.related.parents.traverse((parent) => parent.permits.view(ctx)),
    //highlight-end
  }
}

class Folder implements Namespace {
  related: {
    owners: User[]
    editors: User[]
    viewers: User[]
    parents: Folder[]
  }
}
```

Let's do this for the remaining permissions:

```ts title="permissions-v4.ts"
import { Namespace, Context } from "@ory/keto-namespace-types"

class User implements Namespace {}

class Document implements Namespace {
  related: {
    owners: User[]
    editors: User[]
    viewers: User[]
    parents: Folder[]
  }

  permits = {
    view: (ctx: Context): boolean =>
      this.related.viewers.includes(ctx.subject) ||
      this.related.editors.includes(ctx.subject) ||
      this.related.owners.includes(ctx.subject) ||
      this.related.parents.traverse((parent) => parent.permits.view(ctx)),
    //highlight-start
    edit: (ctx: Context): boolean =>
      this.related.editors.includes(ctx.subject) ||
      this.related.owners.includes(ctx.subject) ||
      this.related.parents.traverse((parent) => parent.permits.edit(ctx)),
    delete: (ctx: Context): boolean =>
      this.related.owners.includes(ctx.subject) || this.related.parents.traverse((parent) => parent.permits.delete(ctx)),
    share: (ctx: Context): boolean =>
      this.related.owners.includes(ctx.subject) || this.related.parents.traverse((parent) => parent.permits.share(ctx)),
    //highlight-end
  }
}

class Folder implements Namespace {
  related: {
    owners: User[]
    editors: User[]
    viewers: User[]
    parents: Folder[]
  }

  //highlight-start
  permits = {
    delete: (ctx: Context): boolean =>
      this.related.owners.includes(ctx.subject) || this.related.parents.traverse((parent) => parent.permits.delete(ctx)),
    share: (ctx: Context): boolean =>
      this.related.owners.includes(ctx.subject) || this.related.parents.traverse((parent) => parent.permits.share(ctx)),
  }
  //highlight-end
}
```

### Optional: refactor permission model code

Notice that our permission model is hierarchical, in the sense that everybody that can `view` can also `edit`, and everybody that
can `edit` can also `delete` and `share`.

Therefore, we can write the `view` permission like this:

```diff
  view: (ctx: Context): boolean =>
    this.related.viewers.includes(ctx.subject) ||
-   this.related.editors.includes(ctx.subject) ||
-   this.related.owners.includes(ctx.subject) ||
-   this.related.parents.traverse((parent) => parent.permits.view(ctx))
+   this.permits.edit(ctx)
```

Applying this to the whole config yields:

```ts title="permissions-v5.ts"
import { Namespace, Context } from "@ory/keto-namespace-types"

class User implements Namespace {}

class Document implements Namespace {
  related: {
    owners: User[]
    editors: User[]
    viewers: User[]
    parents: Folder[]
  }

  permits = {
    view: (ctx: Context): boolean =>
      this.related.viewers.includes(ctx.subject) ||
      //highlight-next-line
      this.permits.edit(ctx),
    edit: (ctx: Context): boolean =>
      this.related.editors.includes(ctx.subject) ||
      //highlight-next-line
      this.permits.share(ctx),
    delete: (ctx: Context): boolean =>
      //highlight-next-line
      this.permits.share(ctx),
    share: (ctx: Context): boolean =>
      this.related.owners.includes(ctx.subject) || this.related.parents.traverse((parent) => parent.permits.share(ctx)),
  }
}

class Folder implements Namespace {
  related: {
    owners: User[]
    editors: User[]
    viewers: User[]
    parents: Folder[]
  }

  permits = {
    delete: (ctx: Context): boolean =>
      //highlight-next-line
      this.permits.share(ctx),
    share: (ctx: Context): boolean =>
      this.related.owners.includes(ctx.subject) || this.related.parents.traverse((parent) => parent.permits.share(ctx)),
  }
}
```

Whether or not this refatoring makes sense in your application depends on your requirements, of course. The take-away is that
these kind of refacorings are possible because the permission config is essentially just code. So you can apply the same techiques
your permission config as to your code to create well-structured and maintainable software systems.

### Test permissions

It is important to test your permission model. To test the permissions manually, you can
[create relationships and check permissions](../guides/simple-access-check-guide.mdx) through the API or SDK.

For continuous testing, we recommend the following best practices:

- Automate testing your permission model. Write a test, that inserts the relationships and checks the permissions through the
  [SDK](../sdk/01_overview.md). Use your preferred programming language.
- For complex permission model changes, use a separate Ory Network project. Each Ory Network project has an isolated permission
  model, so you can iterate on and test your changes on a test project and only deploy the changes once all tests pass.
